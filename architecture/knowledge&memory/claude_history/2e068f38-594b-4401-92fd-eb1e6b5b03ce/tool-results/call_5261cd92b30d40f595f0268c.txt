     1→# AI 记忆系统选型对比报告
     2→
     3→## 一、项目背景
     4→
     5→本报告对比分析了 OmniMem 和 LangMem 两个 AI 记忆管理系统的设计思想和实现方式，并扩展调研了业界主流技术栈（MemGPT/Letta、Mem0、LangGraph Store、向量数据库等），为最终选型提供客观评价和建议。
     6→
     7→---
     8→
     9→## 二、项目详细分析
    10→
    11→### 2.1 OmniMem - 设计文档项目
    12→
    13→#### 项目状态
    14→**⚠️ 重要发现：OmniMem 目前仅为设计文档，未实现源代码**
    15→
    16→#### 核心设计理念
    17→
    18→**1. 系统定位**
    19→- 服务于 LLM、Agent 和各类业务的**通用记忆系统**
    20→- 不仅仅是向量数据库，而是完整的**记忆生命周期管理系统**
    21→- 解决记忆的版本控制、多租户隔离和混合检索问题
    22→
    23→**2. 核心特性**
    24→
    25→| 特性 | 描述 |
    26→|------|------|
    27→| **多租户隔离** | 原生支持租户、用户、应用、Agent、会话等多级正交隔离 |
    28→| **时间旅行 (Time Travel)** | 支持查询任意历史时间点的记忆状态，类似 Git 版本管理 |
    29→| **混合检索** | 融合向量语义检索、关键词检索和结构化过滤 |
    30→| **不可变记录** | Append-only 模式，记录一旦写入永不修改 |
    31→
    32→**3. 技术架构："One Logic, Multi Storage"**
    33→
    34→```
    35→┌─────────────────────────────────────────────┐
    36→│              OmniMem Client                  │
    37→├─────────────────────────────────────────────┤
    38→│  Search  │ Operations │ Pipeline  │  Sync   │
    39→├─────────┼─────────────┼───────────┼─────────┤
    40→│  MongoDB │ PostgreSQL  │Elasticsearch│ Kafka │
    41→│ (主存储) │ (向量索引)  │ (关键词)   │ (异步) │
    42→└─────────────────────────────────────────────┘
    43→```
    44→
    45→**存储职责分工：**
    46→- **MongoDB**: 主存储 (Source of Truth)，存储完整 Memory 对象和历史版本
    47→- **PostgreSQL**: 向量索引，使用 pgvector 进行语义相似度匹配
    48→- **Elasticsearch**: 综合索引，负责全文检索和结构化字段过滤
    49→
    50→**4. 数据模型设计**
    51→
    52→**双 ID 设计：**
    53→- `memory_id`: 逻辑记忆点 ID，所有版本共享
    54→- `record_id`: 物理记录 ID，每次更新产生新 ID
    55→
    56→**Scope 多维正交隔离：**
    57→```python
    58→class Scope:
    59→    tenant_id: str | None
    60→    user_id: str | None
    61→    app_id: str | None
    62→    group_id: str | None
    63→    agent_id: str | None
    64→    run_id: str | None
    65→    namespace: dict[str, str] | None  # 自定义维度
    66→```
    67→
    68→所有维度相互正交，可任意组合过滤。
    69→
    70→**5. IndexHint 灵活索引机制**
    71→- `vector_concat_fields`: 字段拼接后向量化
    72→- `vector_fields`: 独立向量化字段
    73→- 支持路径语法深入 JSON 数组内部
    74→
    75→**6. 不可变记录与时间旅行**
    76→
    77→更新操作本质是 "Append New + Update Pointer"：
    78→- 旧记录标记 `is_latest=false`
    79→- 插入新记录 `is_latest=true`
    80→- 支持查询任意历史时间点的记忆状态
    81→
    82→---
    83→
    84→### 2.2 LangMem - 生产级记忆框架
    85→
    86→#### 项目状态
    87→✅ **完全实现的开源项目，版本 0.0.30**
    88→
    89→#### 核心设计理念
    90→
    91→**1. 系统定位**
    92→- 帮助 Agent 从交互中学习和适应的记忆管理工具
    93→- 提供**功能性原语**（与存储无关）+ **LangGraph 集成**
    94→- 让 Agent 持续改进、个性化响应、跨会话保持一致性
    95→
    96→**2. 核心特性**
    97→
    98→| 特性 | 描述 |
    99→|------|------|
   100→| **核心记忆 API** | 与任何存储系统兼容的功能性原语 |
   101→| **记忆管理工具** | Agent 在对话中主动记录和搜索信息 |
   102→| **后台记忆管理器** | 自动提取、整合和更新 Agent 知识 |
   103→| **LangGraph 原生集成** | 与 LangGraph Long-term Memory Store 深度集成 |
   104→
   105→**3. 三种记忆类型**
   106→
   107→| 记忆类型 | 用途 | Agent 示例 | 人类示例 | 存储模式 |
   108→|---------|------|-----------|---------|---------|
   109→| **Semantic (语义)** | 事实与知识 | 用户偏好；知识三元组 | 知道 Python 是编程语言 | Profile 或 Collection |
   110→| **Episodic (情节)** | 过去经历 | Few-shot 示例；对话摘要 | 记得第一天上班 | Collection |
   111→| **Procedural (程序)** | 系统行为 | 核心性格和响应模式 | 知道如何骑自行车 | Prompt 规则或 Collection |
   112→
   113→**4. 两种记忆写入模式**
   114→
   115→| 模式 | 延迟影响 | 更新速度 | 处理负载 | 使用场景 |
   116→|------|---------|---------|---------|---------|
   117→| **Active (主动)** | 较高 | 立即 | 响应期间 | 关键上下文更新 |
   118→| **Background (后台)** | 无 | 延迟 | 调用之间/之后 | 模式分析、摘要 |
   119→
   120→**5. 两种语义记忆存储模式**
   121→
   122→**Collection (集合型)：**
   123→- 记忆以独立文档/记录形式存储
   124→- 每次对话可插入新记忆
   125→- 需要平衡记忆创建与整合
   126→- 支持删除/失效/更新/合并现有记忆
   127→
   128→**Profile (档案型)：**
   129→- 单一文档表示当前状态
   130→- 新信息更新现有文档而非创建新文档
   131→- 只关心最新状态
   132→- 适合快速访问和严格数据要求
   133→
   134→**6. 技术架构**
   135→
   136→**核心 API（无存储依赖）：**
   137→- `create_memory_manager`: 提取新记忆、更新/移除过时记忆、整合现有记忆
   138→- `create_prompt_optimizer`: 基于对话信息更新 prompt 规则
   139→
   140→**有状态集成（依赖 LangGraph Store）：**
   141→- `create_memory_store_manager`: 自动持久化提取的记忆
   142→- `create_manage_memory_tool`: 提供 Agent 直接访问记忆操作
   143→
   144→**7. 存储系统**
   145→
   146→基于 **LangGraph Store** 原语：
   147→- **Memory Namespaces**: 多级命名空间组织记忆
   148→- **Flexible Retrieval**:
   149→  - Direct Access: 通过 key 直接获取
   150→  - Semantic Search: 语义相似度搜索
   151→  - Metadata Filtering: 按属性过滤
   152→
   153→**8. 依赖栈**
   154→```
   155→langmem
   156→├── langchain (>=0.3.15)
   157→├── langchain-core (>=0.3.46)
   158→├── langchain-openai (>=0.3.1)
   159→├── trustcall (>=0.0.39)
   160→├── langgraph (>=0.6.0, <2)
   161→├── langchain-anthropic (>=0.3.3)
   162→├── langsmith (>=0.3.8)
   163→└── langgraph-checkpoint (>=2.0.12)
   164→```
   165→
   166→---
   167→
   168→## 三、业界主流技术栈对比
   169→
   170→### 3.1 MemGPT / Letta
   171→
   172→**核心特点：**
   173→- 受操作系统内存层次结构启发的**分层记忆系统**
   174→- **虚拟上下文管理**技术
   175→- 两层记忆架构（类似主存和辅存）
   176→- **自编辑记忆**能力
   177→- 将对话转化为持久、进化的关系
   178→
   179→**优势：**
   180→- 成熟的学术研究基础
   181→- 创新的虚拟上下文管理
   182→- 持久化对话关系
   183→- 已进化为 Letta 项目（2025）
   184→
   185→**适用场景：**
   186→- 需要长期对话历史的场景
   187→- 复杂的 Agent 交互
   188→- 需要自适应记忆管理
   189→
   190→**资源：**
   191→- [MemGPT: Engineering Semantic Memory](https://informationmatters.org/2025/10/memgpt-engineering-semantic-memory-through-adaptive-retention-and-context-summarization/)
   192→- [Letta Project](https://www.leoniemonigatti.com/papers/memgpt.html)
   193→
   194→---
   195→
   196→### 3.2 Mem0
   197→
   198→**核心特点：**
   199→- "Universal, self-improving memory layer for LLM applications"
   200→- **智能记忆层**，支持个性化 AI 交互
   201→- 自我改进和自适应学习
   202→- **显著的成本和性能优化**：
   203→  - Token 成本降低 90%
   204→  - 延迟降低 91%
   205→  - 长期上下文保留
   206→
   207→**社区活跃度：**
   208→- GitHub Stars: **41,000+**
   209→- API 调用：**1.86 亿次/季度**（2025 Q4）
   210→
   211→**优势：**
   212→- 非常活跃的开源社区
   213→- 生产就绪
   214→- 多 Agent 团队支持（CrewAI 集成）
   215→- 成本和性能优势明显
   216→
   217→**适用场景：**
   218→- 需要成本优化的生产环境
   219→- 多 Agent 协作
   220→- 个性化 AI 体验
   221→
   222→**资源：**
   223→- [Mem0 官网](https://mem0.ai/)
   224→- [GitHub](https://github.com/mem0ai/mem0)
   225→- [Arxiv 论文](https://arxiv.org/abs/2504.19413)
   226→
   227→---
   228→
   229→### 3.3 LangGraph Store
   230→
   231→**核心特点：**
   232→- LangGraph 官方持久化层
   233→- **双记忆系统**：
   234→  - Short-term: 单个对话线程
   235→  - Long-term: 跨会话、应用级存储
   236→- **BaseStore 接口**：抽象存储接口
   237→- **多后端支持**：InMemoryStore、AsyncPostgresStore 等
   238→
   239→**优势：**
   240→- 与 LangChain/LangGraph 生态系统深度集成
   241→- 灵活的命名空间机制
   242→- 支持语义搜索和元数据过滤
   243→- 官方维护，文档完善
   244→
   245→**适用场景：**
   246→- 已使用 LangGraph 生态的项目
   247→- 需要跨线程记忆共享
   248→- LangChain/LangGraph 技术栈
   249→
   250→**资源：**
   251→- [LangGraph Memory 文档](https://langgraph.com.cn/concepts/memory.1.html)
   252→- [GitHub LangChain 文档](https://github.langchain.ac.cn/langgraph/concepts/memory/)
   253→
   254→---
   255→
   256→### 3.4 向量数据库（用于 RAG）
   257→
   258→**主流选择（2025）：**
   259→
   260→| 数据库 | 特点 | 适用场景 |
   261→|-------|------|---------|
   262→| **Pinecone** | 托管服务，高性能 | 快速原型开发，云原生应用 |
   263→| **Weaviate** | 开源，GraphQL API | 需要自主控制，灵活查询 |
   264→| **Milvus** | 开源，高性能向量搜索 | 大规模部署，性能要求高 |
   265→| **Qdrant** | Rust 实现，高性能 | 需要高性能和低延迟 |
   266→| **pgvector** | PostgreSQL 扩展 | 已使用 PostgreSQL 的场景 |
   267→| **Chroma** | 轻量级，易用 | 原型开发，本地测试 |
   268→
   269→**参考资源：**
   270→- [Best Vector Databases 2025 - Firecrawl](https://www.firecrawl.dev/blog/best-vector-databases-2025)
   271→- [Best 17 Vector Databases - LakeFS](https://lakefs.io/blog/best-vector-databases/)
   272→- [Vector Databases for RAG - LateNode](https://latenode.com/blog/ai-frameworks-technical-infrastructure/vector-databases-embeddings/best-vector-databases-for-rag-complete-2025-comparison-guide)
   273→
   274→---
   275→
   276→## 四、OmniMem vs LangMem 对比分析
   277→
   278→### 4.1 设计理念对比
   279→
   280→| 维度 | OmniMem | LangMem |
   281→|-----|---------|---------|
   282→| **定位** | 通用记忆基础设施 | Agent 记忆工具库 |
   283→| **设计哲学** | "One Logic, Multi Storage" | 功能性原语 + 可选集成 |
   284→| **核心理念** | 记忆生命周期管理 | Agent 学习与适应 |
   285→| **实现状态** | ❌ 仅设计文档 | ✅ 生产就绪 |
   286→
   287→### 4.2 功能特性对比
   288→
   289→| 功能 | OmniMem | LangMem |
   290→|-----|---------|---------|
   291→| **多租户隔离** | ✅ 6维正交隔离 | ⚠️ 通过命名空间实现 |
   292→| **版本控制** | ✅ Git-like 时间旅行 | ❌ 无原生版本控制 |
   293→| **混合检索** | ✅ 向量+关键词+元数据 | ⚠️ 依赖 LangGraph Store |
   294→| **不可变记录** | ✅ Append-only | ❌ 未明确 |
   295→| **记忆类型** | ❌ 无类型划分 | ✅ Semantic/Episodic/Procedural |
   296→| **主动/后台写入** | ❌ 无 | ✅ 两种模式 |
   297→| **Prompt 优化** | ❌ 无 | ✅ create_prompt_optimizer |
   298→| **记忆工具** | ❌ 无 | ✅ Agent 可用工具 |
   299→
   300→### 4.3 存储架构对比
   301→
   302→| 维度 | OmniMem | LangMem |
   303→|-----|---------|---------|
   304→| **存储依赖** | MongoDB + PostgreSQL + ES + Kafka | 任意（通过 LangGraph Store） |
   305→| **复杂度** | 高（多存储协调） | 低（抽象接口） |
   306→| **Source of Truth** | MongoDB | 可配置 |
   307→| **向量索引** | PostgreSQL (pgvector) | Store 依赖 |
   308→| **全文检索** | Elasticsearch | Store 依赖 |
   309→| **异步处理** | Kafka | 未明确 |
   310→
   311→### 4.4 生态集成对比
   312→
   313→| 维度 | OmniMem | LangMem |
   314→|-----|---------|---------|
   315→| **框架集成** | ❌ 无 | ✅ LangGraph/LangChain 深度集成 |
   316→| **LLM 供应商** | 未明确 | ✅ Anthropic、OpenAI 等 |
   317→| **监控/追踪** | ❌ 无 | ✅ LangSmith 集成 |
   318→| **开发工具** | ❌ 无 | ✅ CLI、测试工具 |
   319→
   320→### 4.5 成熟度对比
   321→
   322→| 维度 | OmniMem | LangMem |
   323→|-----|---------|---------|
   324→| **实现状态** | 设计文档 | 生产代码 |
   325→| **版本** | - | 0.0.30 |
   326→| **文档** | 详细设计文档 | API 文档 + 指南 |
   327→| **社区** | 无 | LangChain 生态 |
   328→| **案例** | 无 | 多个指南示例 |
   329→
   330→---
   331→
   332→## 五、客观评价
   333→
   334→### 5.1 OmniMem 评价
   335→
   336→**✅ 优点：**
   337→1. **设计理念先进**：Git-like 版本控制、时间旅行、不可变记录
   338→2. **架构清晰**：职责分离明确，One Logic Multi Storage
   339→3. **多租户设计优秀**：正交隔离维度，灵活扩展
   340→4. **混合检索完善**：向量+关键词+元数据过滤
   341→5. **索引策略灵活**：IndexHint 机制精细控制
   342→
   343→**❌ 缺点：**
   344→1. **未实现**：仅有设计文档，无可用代码
   345→2. **复杂度高**：多存储协调、同步、一致性挑战
   346→3. **运维成本高**：需维护 MongoDB、PostgreSQL、ES、Kafka
   347→4. **生态孤立**：无框架集成，无社区支持
   348→5. **过度设计风险**：时间旅行、版本控制可能过度工程化
   349→
   350→**适用场景：**
   351→- 需要审计、合规、历史回溯的场景
   352→- 多租户 SaaS 平台
   353→- 需要严格版本控制的知识管理
   354→
   355→**实现建议：**
   356→- 分阶段实现：先 MongoDB，再 PG，后 ES
   357→- 简化设计：考虑是否真的需要时间旅行
   358→- 参考现有框架：借鉴 LangMem 的记忆类型划分
   359→
   360→---
   361→
   362→### 5.2 LangMem 评价
   363→
   364→**✅ 优点：**
   365→1. **生产就绪**：完整的实现，0.0.30 版本
   366→2. **生态集成优秀**：与 LangGraph/LangChain 无缝集成
   367→3. **设计理念先进**：三种记忆类型、主动/后台写入
   368→4. **灵活性强**：核心 API 无存储依赖，可选集成
   369→5. **文档完善**：概念指南、API 参考、快速入门
   370→6. **Prompt 优化**：独特的自适应 prompt 能力
   371→
   372→**❌ 缺点：**
   373→1. **版本控制弱**：无原生历史版本管理
   374→2. **多租户隔离弱**：依赖命名空间，无正交设计
   375→3. **混合检索依赖**：检索能力取决于 LangGraph Store
   376→4. **框架绑定**：深度绑定 LangChain 生态
   377→5. **复杂场景支持有限**：缺少审计、合规等企业级功能
   378→
   379→**适用场景：**
   380→- 已使用 LangChain/LangGraph 的项目
   381→- Agent 需要学习和适应的场景
   382→- 需要快速集成记忆功能
   383→- 对话式 AI 应用
   384→
   385→---
   386→
   387→## 六、最终选型建议
   388→
   389→### 6.1 场景映射
   390→
   391→| 场景 | 推荐方案 | 理由 |
   392→|-----|---------|------|
   393→| **快速原型 / 已使用 LangGraph** | **LangMem** | 即插即用，生态集成 |
   394→| **需要审计 / 历史回溯** | **OmniMem（需实现）或自建** | LangMem 无版本控制 |
   395→| **多租户 SaaS 平台** | **OmniMem（需实现）或 Mem0** | OmniMem 设计更完善 |
   396→| **多 Agent 协作** | **Mem0** | CrewAI 集成，生产验证 |
   397→| **长期对话历史** | **MemGPT/Letta** | 虚拟上下文管理 |
   398→| **成本敏感的生产环境** | **Mem0** | 90% 成本降低 |
   399→| **已有 PostgreSQL** | **LangMem + pgvector** | 最小化新增组件 |
   400→
   401→### 6.2 综合选型矩阵
   402→
   403→| 方案 | 成熟度 | 功能完整度 | 易用性 | 性能 | 成本 | 生态 | **推荐指数** |
   404→|-----|-------|----------|-------|------|------|------|------------|
   405→| **LangMem** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** (LangGraph 生态) |
   406→| **Mem0** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** (生产环境) |
   407→| **MemGPT/Letta** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | **⭐⭐⭐⭐** (长期对话) |
   408→| **OmniMem** | ⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐ | **⭐⭐⭐** (需实现) |
   409→
   410→### 6.3 具体建议
   411→
   412→**如果您的团队：**
   413→
   414→1. **已使用 LangChain/LangGraph**
   415→   - **首选：LangMem**
   416→   - 理由：无缝集成，快速上手，生态完善
   417→
   418→2. **从零开始，追求生产就绪**
   419→   - **首选：Mem0**
   420→   - 理由：41k+ stars，1.86 亿 API 调用，成本优化明显
   421→
   422→3. **需要审计、合规、历史回溯**
   423→   - **选项 1：实现 OmniMem**
   424→     - 优点：设计完善
   425→     - 缺点：需从零实现
   426→   - **选项 2：LangMem/Mem0 + 自建版本层**
   427→     - 优点：复用成熟框架
   428→     - 缺点：集成复杂
   429→
   430→4. **多租户 SaaS 平台**
   431→   - **推荐：Mem0**
   432→   - 备选：实现 OmniMem（如需更精细隔离）
   433→
   434→5. **学术研究 / 复杂对话场景**
   435→   - **推荐：MemGPT/Letta**
   436→   - 理由：创新架构，学术支持
   437→
   438→---
   439→
   440→## 七、OmniMem 实现路线图建议
   441→
   442→如果决定实现 OmniMem，建议分阶段：
   443→
   444→### Phase 1: MVP（最小可行产品）
   445→- [ ] MongoDB 实现（Source of Truth）
   446→- [ ] 基础 CRUD 操作
   447→- [ ] Scope 隔离
   448→- [ ] 简单向量检索（OpenAI API）
   449→
   450→### Phase 2: 向量索引
   451→- [ ] PostgreSQL + pgvector 集成
   452→- [ ] IndexHint 实现
   453→- [ ] 混合检索引擎
   454→
   455→### Phase 3: 全文检索
   456→- [ ] Elasticsearch 集成
   457→- [ ] 动态类型后缀机制
   458→- [ ] 多路召回 + RRF 融合
   459→
   460→### Phase 4: 高级特性
   461→- [ ] 时间旅行查询
   462→- [ ] 版本回滚
   463→- [ ] Kafka 异步同步
   464→
   465→### Phase 5: 生产就绪
   466→- [ ] 监控、日志、指标
   467→- [ ] 测试覆盖率
   468→- [ ] 文档、示例
   469→
   470→---
   471→
   472→## 八、总结
   473→
   474→### 关键发现
   475→
   476→1. **OmniMem** 是一个设计优秀但未实现的项目，其 Git-like 版本控制和多租户设计理念先进，但实现复杂度高。
   477→
   478→2. **LangMem** 是生产就绪的框架，与 LangGraph 生态深度集成，适合快速开发，但缺少版本控制等企业级功能。
   479→
   480→3. **业界主流**：Mem0（生产验证）、MemGPT/Letta（学术创新）、LangGraph Store（生态集成）各有优势。
   481→
   482→4. **向量数据库**是记忆系统的底层基础设施，pgvector、Pinecone、Weaviate 等是主流选择。
   483→
   484→### 最终建议
   485→
   486→**对于 OmniMem：**
   487→- 评估是否真的需要时间旅行、版本控制等高级特性
   488→- 考虑基于 Mem0 或 LangMem 扩展，而非从零实现
   489→- 如需实现，采用分阶段策略，先 MVP 后优化
   490→
   491→**选型优先级：**
   492→1. **LangGraph 生态** → LangMem
   493→2. **生产环境** → Mem0
   494→3. **长期对话** → MemGPT/Letta
   495→4. **特殊需求**（审计、合规）→ 考虑实现 OmniMem 或自建
   496→
   497→---
   498→
   499→## 九、参考资料
   500→
   501→### 项目文档
   502→- [OmniMem 设计文档](/Users/magooup/workspace/default/research/memory/omnimem/docs/DESIGN.md)
   503→- [LangMem GitHub](https://github.com/langchain-ai/langmem)
   504→- [LangMem 官方文档](https://langchain-ai.github.io/langmem/)
   505→
   506→### 业界资源
   507→- [Mem0 官网](https://mem0.ai/)
   508→- [MemGPT: Engineering Semantic Memory](https://informationmatters.org/2025/10/memgpt-engineering-semantic-memory-through-adaptive-retention-and-context-summarization/)
   509→- [LangGraph Memory 文档](https://langgraph.com.cn/concepts/memory.1.html)
   510→- [Best Vector Databases 2025 - Firecrawl](https://www.firecrawl.dev/blog/best-vector-databases-2025)
   511→- [Best 17 Vector Databases - LakeFS](https://lakefs.io/blog/best-vector-databases/)
   512→- [AI Memory Systems Benchmark](https://guptadeepak.com/the-ai-memory-wars-why-one-system-crushed-the-competition-and-its-not-openai/)
   513→
   514→### 学术论文
   515→- [Mem0: Building Production-Ready AI Agents](https://arxiv.org/abs/2504.19413)
   516→- [A-MEM: Agentic Memory for LLM Agents](https://arxiv.org/pdf/2502.12110)
   517→- [Memory OS of AI Agent](https://aclanthology.org/2025.emnlp-main.1318.pdf)
   518→
   519→---
   520→
   521→**报告生成时间：** 2025-01-10
   522→**分析版本：**
   523→- OmniMem: 设计文档
   524→- LangMem: v0.0.30
   525→

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
