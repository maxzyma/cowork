     1→# AI 记忆系统选型对比报告
     2→
     3→## 一、项目背景
     4→
     5→本报告对比分析了 OmniMem 和 LangMem 两个 AI 记忆管理系统的设计思想和实现方式，并扩展调研了业界主流技术栈（MemGPT/Letta、Mem0、LangGraph Store、向量数据库等），为最终选型提供客观评价和建议。
     6→
     7→---
     8→
     9→## 二、项目详细分析
    10→
    11→### 2.1 OmniMem - 设计文档项目
    12→
    13→#### 项目状态
    14→**⚠️ 重要发现：OmniMem 目前仅为设计文档，未实现源代码**
    15→
    16→#### 核心设计理念
    17→
    18→**1. 系统定位**
    19→- 服务于 LLM、Agent 和各类业务的**通用记忆系统**
    20→- 不仅仅是向量数据库，而是完整的**记忆生命周期管理系统**
    21→- 解决记忆的版本控制、多租户隔离和混合检索问题
    22→
    23→**2. 核心特性**
    24→
    25→| 特性 | 描述 |
    26→|------|------|
    27→| **多租户隔离** | 原生支持租户、用户、应用、Agent、会话等多级正交隔离 |
    28→| **时间旅行 (Time Travel)** | 支持查询任意历史时间点的记忆状态，类似 Git 版本管理 |
    29→| **混合检索** | 融合向量语义检索、关键词检索和结构化过滤 |
    30→| **不可变记录** | Append-only 模式，记录一旦写入永不修改 |
    31→
    32→**3. 技术架构："One Logic, Multi Storage"**
    33→
    34→```
    35→┌─────────────────────────────────────────────┐
    36→│              OmniMem Client                  │
    37→├─────────────────────────────────────────────┤
    38→│  Search  │ Operations │ Pipeline  │  Sync   │
    39→├─────────┼─────────────┼───────────┼─────────┤
    40→│  MongoDB │ PostgreSQL  │Elasticsearch│ Kafka │
    41→│ (主存储) │ (向量索引)  │ (关键词)   │ (异步) │
    42→└─────────────────────────────────────────────┘
    43→```
    44→
    45→**存储职责分工：**
    46→- **MongoDB**: 主存储 (Source of Truth)，存储完整 Memory 对象和历史版本
    47→- **PostgreSQL**: 向量索引，使用 pgvector 进行语义相似度匹配
    48→- **Elasticsearch**: 综合索引，负责全文检索和结构化字段过滤
    49→
    50→**4. 数据模型设计**
    51→
    52→**双 ID 设计：**
    53→- `memory_id`: 逻辑记忆点 ID，所有版本共享
    54→- `record_id`: 物理记录 ID，每次更新产生新 ID
    55→
    56→**Scope 多维正交隔离：**
    57→```python
    58→class Scope:
    59→    tenant_id: str | None
    60→    user_id: str | None
    61→    app_id: str | None
    62→    group_id: str | None
    63→    agent_id: str | None
    64→    run_id: str | None
    65→    namespace: dict[str, str] | None  # 自定义维度
    66→```
    67→
    68→所有维度相互正交，可任意组合过滤。
    69→
    70→**5. IndexHint 灵活索引机制**
    71→- `vector_concat_fields`: 字段拼接后向量化
    72→- `vector_fields`: 独立向量化字段
    73→- 支持路径语法深入 JSON 数组内部
    74→
    75→**6. 不可变记录与时间旅行**
    76→
    77→更新操作本质是 "Append New + Update Pointer"：
    78→- 旧记录标记 `is_latest=false`
    79→- 插入新记录 `is_latest=true`
    80→- 支持查询任意历史时间点的记忆状态
    81→
    82→---
    83→
    84→### 2.2 LangMem - 生产级记忆框架
    85→
    86→#### 项目状态
    87→✅ **完全实现的开源项目，版本 0.0.30**
    88→
    89→#### 核心设计理念
    90→
    91→**1. 系统定位**
    92→- 帮助 Agent 从交互中学习和适应的记忆管理工具
    93→- 提供**功能性原语**（与存储无关）+ **LangGraph 集成**
    94→- 让 Agent 持续改进、个性化响应、跨会话保持一致性
    95→
    96→**2. 核心特性**
    97→
    98→| 特性 | 描述 |
    99→|------|------|
   100→| **核心记忆 API** | 与任何存储系统兼容的功能性原语 |

<system-reminder>
Whenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.
</system-reminder>
